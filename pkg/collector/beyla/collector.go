package beyla

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	dto "github.com/prometheus/client_model/go"
	"github.com/prometheus/common/expfmt"
	"github.com/sirupsen/logrus"

	"github.com/wrongerror/observo-connector/pkg/collector"
)

// Collector implements collector.Collector for Beyla
type Collector struct {
	logger     *logrus.Logger
	config     collector.Config
	httpClient *http.Client

	// Metric descriptors for transformed Beyla metrics
	beylaHTTPDuration    *collector.TypedDesc
	beylaHTTPRequests    *collector.TypedDesc
	beylaTracesGenerated *collector.TypedDesc
}

// NewCollector creates a new Beyla collector
func NewCollector(logger *logrus.Logger, config collector.Config) (collector.Collector, error) {
	if !config.BeylaEnabled {
		return nil, fmt.Errorf("beyla collector is disabled")
	}

	if config.BeylaAddress == "" {
		return nil, fmt.Errorf("beyla address is required")
	}

	httpClient := &http.Client{
		Timeout: 10 * time.Second,
	}

	return &Collector{
		logger:     logger,
		config:     config,
		httpClient: httpClient,

		// Define metric descriptors for transformed metrics
		beylaHTTPDuration: collector.NewTypedDesc(
			"beyla_http_request_duration_seconds",
			"HTTP request duration from Beyla",
			prometheus.GaugeValue,
			[]string{"service", "method", "status_code"},
		),
		beylaHTTPRequests: collector.NewTypedDesc(
			"beyla_http_requests_total",
			"Total HTTP requests from Beyla",
			prometheus.CounterValue,
			[]string{"service", "method", "status_code"},
		),
		beylaTracesGenerated: collector.NewTypedDesc(
			"beyla_traces_generated_total",
			"Total traces generated by Beyla",
			prometheus.CounterValue,
			[]string{"service"},
		),
	}, nil
}

// Update implements collector.Collector interface
func (c *Collector) Update(ch chan<- prometheus.Metric) error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Fetch metrics from Beyla
	metricsURL := fmt.Sprintf("%s/metrics", strings.TrimSuffix(c.config.BeylaAddress, "/"))

	req, err := http.NewRequestWithContext(ctx, "GET", metricsURL, nil)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to fetch metrics from beyla: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("beyla returned non-200 status: %d", resp.StatusCode)
	}

	// Parse Prometheus metrics
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %w", err)
	}

	// Parse and transform metrics
	if err := c.parseAndTransformMetrics(body, ch); err != nil {
		return fmt.Errorf("failed to parse beyla metrics: %w", err)
	}

	return nil
}

// parseAndTransformMetrics parses Beyla's Prometheus metrics and transforms them
func (c *Collector) parseAndTransformMetrics(data []byte, ch chan<- prometheus.Metric) error {
	var parser expfmt.TextParser
	metricFamilies, err := parser.TextToMetricFamilies(strings.NewReader(string(data)))
	if err != nil {
		return fmt.Errorf("failed to parse metrics: %w", err)
	}

	for name, mf := range metricFamilies {
		c.logger.WithField("metric_name", name).Debug("Processing Beyla metric")

		switch name {
		case "beyla_http_request_duration_seconds":
			c.processHTTPDurationMetric(mf, ch)
		case "beyla_http_requests_total":
			c.processHTTPRequestsMetric(mf, ch)
		case "beyla_instrumented_functions":
			c.processInstrumentedFunctionsMetric(mf, ch)
		default:
			// For other metrics, just pass them through with a prefix
			c.processGenericMetric(name, mf, ch)
		}
	}

	return nil
}

// processHTTPDurationMetric processes HTTP duration metrics from Beyla
func (c *Collector) processHTTPDurationMetric(mf *dto.MetricFamily, ch chan<- prometheus.Metric) {
	for _, metric := range mf.Metric {
		labels := make(map[string]string)
		for _, label := range metric.Label {
			labels[*label.Name] = *label.Value
		}

		service := labels["service_name"]
		if service == "" {
			service = "unknown"
		}

		method := labels["http_method"]
		if method == "" {
			method = "unknown"
		}

		statusCode := labels["status_code"]
		if statusCode == "" {
			statusCode = "unknown"
		}

		var value float64
		if metric.Gauge != nil {
			value = *metric.Gauge.Value
		} else if metric.Counter != nil {
			value = *metric.Counter.Value
		} else if metric.Histogram != nil {
			// Use bucket sum / count for average
			if metric.Histogram.SampleCount != nil && *metric.Histogram.SampleCount > 0 {
				value = *metric.Histogram.SampleSum / float64(*metric.Histogram.SampleCount)
			}
		}

		ch <- c.beylaHTTPDuration.MustNewConstMetric(value, service, method, statusCode)
	}
}

// processHTTPRequestsMetric processes HTTP requests count metrics from Beyla
func (c *Collector) processHTTPRequestsMetric(mf *dto.MetricFamily, ch chan<- prometheus.Metric) {
	for _, metric := range mf.Metric {
		labels := make(map[string]string)
		for _, label := range metric.Label {
			labels[*label.Name] = *label.Value
		}

		service := labels["service_name"]
		if service == "" {
			service = "unknown"
		}

		method := labels["http_method"]
		if method == "" {
			method = "unknown"
		}

		statusCode := labels["status_code"]
		if statusCode == "" {
			statusCode = "unknown"
		}

		var value float64
		if metric.Counter != nil {
			value = *metric.Counter.Value
		} else if metric.Gauge != nil {
			value = *metric.Gauge.Value
		}

		ch <- c.beylaHTTPRequests.MustNewConstMetric(value, service, method, statusCode)
	}
}

// processInstrumentedFunctionsMetric processes instrumented functions metric
func (c *Collector) processInstrumentedFunctionsMetric(mf *dto.MetricFamily, ch chan<- prometheus.Metric) {
	for _, metric := range mf.Metric {
		labels := make(map[string]string)
		for _, label := range metric.Label {
			labels[*label.Name] = *label.Value
		}

		service := labels["service_name"]
		if service == "" {
			service = "unknown"
		}

		var value float64
		if metric.Counter != nil {
			value = *metric.Counter.Value
		} else if metric.Gauge != nil {
			value = *metric.Gauge.Value
		}

		ch <- c.beylaTracesGenerated.MustNewConstMetric(value, service)
	}
}

// processGenericMetric processes other metrics from Beyla with a prefix
func (c *Collector) processGenericMetric(name string, mf *dto.MetricFamily, ch chan<- prometheus.Metric) {
	// Create a new metric name with our namespace
	newName := fmt.Sprintf("beyla_%s", strings.TrimPrefix(name, "beyla_"))

	for _, metric := range mf.Metric {
		// Extract labels
		labelNames := make([]string, 0, len(metric.Label))
		labelValues := make([]string, 0, len(metric.Label))

		for _, label := range metric.Label {
			labelNames = append(labelNames, *label.Name)
			labelValues = append(labelValues, *label.Value)
		}

		// Create metric descriptor
		desc := prometheus.NewDesc(
			prometheus.BuildFQName(collector.Namespace, "", newName),
			*mf.Help,
			labelNames,
			nil,
		)

		var value float64
		var metricType prometheus.ValueType

		switch *mf.Type {
		case dto.MetricType_COUNTER:
			metricType = prometheus.CounterValue
			if metric.Counter != nil {
				value = *metric.Counter.Value
			}
		case dto.MetricType_GAUGE:
			metricType = prometheus.GaugeValue
			if metric.Gauge != nil {
				value = *metric.Gauge.Value
			}
		case dto.MetricType_HISTOGRAM:
			metricType = prometheus.GaugeValue
			if metric.Histogram != nil && metric.Histogram.SampleCount != nil && *metric.Histogram.SampleCount > 0 {
				value = *metric.Histogram.SampleSum / float64(*metric.Histogram.SampleCount)
			}
		default:
			continue // Skip unsupported metric types
		}

		ch <- prometheus.MustNewConstMetric(desc, metricType, value, labelValues...)
	}
}

func init() {
	// Register the Beyla collector
	collector.RegisterCollector("beyla", NewCollector)
}
